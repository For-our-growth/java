# Multi Thread

##### - 책 '이것이 자바다'를 참고해서 작성한 문서입니다.



#### 공유 객체 사용 주의점

멀티 스레드 프로그램에선 스레드들이 객체를 공유해 작업해야 하는 경우가 있다.

이 경우,  스레드 A를 사용하던 객체가 스레드 B에 의해 상태가 변경될 수 있기 때문에 스레드 A가 의도했던 것과는 다른 결과를 산출할 수 있다.



#### 동기화 메소드 및 동기화 블록

- 임계 영역(critical section): 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역

자바는 임계 영역을 지정하기 위해 동기화(synchronized) 메소드와 동기화 블록을 제공한다. 스레드가 객체 내부의 동기화 메소드 또는 블록에 들어가면 즉시 객체에 잠금을 걸어 다른 스레드가 임계 영역 코드를 실행하지 못하도록 한다.

동기화 메소드를 만드는 방법은 메소드 선언에 synchronized 키워드를 붙이면 된다. 이는 인스턴스와 정적 메소드 어디든 붙일 수 있다.

```java
public synchronized void method() {
	임계 영역;	// 단 하나의 스레드만 실행
}
```

동기화 메소드는 메소드 전체 내용이 임계 영역이므로 스레드가 동기화 메소드를 실행하는 즉시 객체에는 잠금이 일어나고, 스레드가 동기화 메소드를 실행 종료하면 잠금이 풀린다.

메소드 전체 내용이 아니라, 일부 내용만 임계 영역으로 만들고 싶다면 다음과 같이 동기화(synchronized) 블록을 만들면 된다.

```java
public void method() {
	// 여러 스레드가 실행 가능한 영역
	...
	synchronized(공유 객체) {
		임계 영역	// 단 하나의 스레드만 실행
	}
	// 여러 스레드가 실행 가능한 영역
	...
}
```



#### 스레드 상태

스레드 객체를 생성하고, start() 메소드를 호출하면 바로 스레드가 실행되는 것처럼 보이지만 사실 **실행 대기 상태**가 된다.

- 실행 대기 상태: 아직 스케줄링이 되지 않아서 실행을 기다리고 있는 상태

실행 대기 상태에 있는 스레드 중에서 스레드 스케줄링으로 선택된 스레드가 CPU를 점유하고 run() 메소드를 실행한다. 이때를 **실행(Running) 상태**라고 한다.

실행 상태의 스레드는 run() 메소드를 모두 실행하기 전에 스레드 스케줄링에 의해 다시 실행 대기 상태로 돌아갈 수 있다. 그리고 실행 대기 상태에 있는 다른 스레드가 선택되어 실행 상태가 된다.

스레드는 실행 대기 상태와 실행 상태를 번갈아가면서 자신의 run() 메소드를 조금씩 실행한다. 실행 상태에서 run() 메소드가 종료되면, 더 이상 실행할 코드가 없기 때문에 스레드의 실행은 멈추게 된다. 이 상태를 **종료 상태**라고 한다.

경우에 따라 스레드는 실행 상태에서 실행 대기 상태로 가지 않을 수도 있다. 실행 상태에서 **일시 정지 상태**로 가기도 한다. 이는 스레드가 실행할 수 없는 상태이다. 여기엔 WAITING, TIMED_WAITING, BLOCKED가 있다.

이런 스레드 상태를 코드에서 확인할 수 있도록 자바 5부터 Thread 클래스에 getState() 메소드가 추가되었다. 스레드 상태에 따라 열거 상수를 리턴한다.

| 상태      | 열거 상수    | 설명                                                         |
| :-------- | ------------ | :----------------------------------------------------------- |
| 객체 생성 | NEW          | 스레드 객체가 생성, 아직 start() 메소드가 호출되지 않은 상태 |
| 실행 대기 | RUNNABLE     | 실행 상태로 언제든지 갈 수 있는 상태                         |
| 일시 정지 | WAITING      | 다른 스레드가 통지할 때까지 기다리는 상태                    |
| 일시 정지 | TIME_WAITING | 주어진 시간 동안 기다리는 상태                               |
| 일시 정지 | BLOCKED      | 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태        |
| 종료      | TERMINATED   | 실행을 마친 상태                                             |



#### 스레드 상태 제어

![thread1](C:\Users\a\Desktop\thread1.png)

##### 주어진 시간동안 일시 정지 (sleep())

실행 중인 스레드를 일정 시간 멈추고 싶다면 Thread 클래스의 정적 메소드인 sleep()을 사용하면 된다. 주어진 시간이 지나면 일시 정지 상태에서 실행 대기 상태로 돌아간다.

```java
try {
	Thread.sleep(1000);
} catch(InterruptedException e) {
	// interrupt() 메소드가 호출되면 실행
}
```

##### 다른 스레드에게 실행 양보 (yield())

yield() 메소드를 호출한 스레드는 실행 대기 상태로 돌아가고 동일한 우선순위 또는 높은 우선순위를 갖는 다른 스레드가 실행 기회를 가질 수 있도록 해준다. 의미 없는 반복을 줄여 다른 스레드에게 실행 기회를 줄 수 있다.

```java
public void run() {
	while(true) {
		if(work) {
			System.out.println("ThreadA 작업 내용");
		} else {
			Thread.yield();
		}
	}
}

/* yield() 메소드를 안쓴 코드
 * public void run() {
 * 	   while(true) {
 * 	   	   if(work) {
 * 	   	   	   System.out.println("ThreadA 작업 내용");
 * 	   	   }
 *     }
 * }
 */
```

##### 다른 스레드의 종료를 기다림 (join())

스레드는 다른 스레드와 독립적으로 실행하는 것이 기본이지만 다른 스레드가 종료될 때까지 기다렸다가 실행해야 하는 경우가 있다. 이 경우를 위해 Thread는 join() 메소드를 제공한다.

##### 스레드 간 협업 (wait(), notify(), notifyAll())

경우에 따라 두 스레드를 교대로 번갈아가며 실행해야 하는 경우가 있다. 정확한 교대 작업이 필요할 경우, 자신의 작업이 끝나면 상대방 스레드를 일시 정지 상태에서 풀어주고, 자신은 일시 정지 상태로 만드는 것이다. 이 방법의 핵심은 공유 객체에 있다. 공유 객체는 두 스레드가 작업할 내용을 각각 동기화 메소드로 구분해 놓는다.

한 스레드가 작업을 완료하면 notify() 메소드로 일시 정지 상태에 있는 다른 스레드를 실행 대기 상태로 만들고, 자신은 두 번 작업을 하지 않도록 wait() 메소드를 호출해 일시 정지 상태로 만든다.

notifyAll() 메소드는 wait()에 의해 일시 정지된 모든 스레드들을 실행 대기 상태로 만든다.

이 메소드들은 Object 클래스에 선언된 메소드이므로 모든 공유 객체에서 호출이 가능하다. 주의할 점은 이 메소드들은 동기화 메소드 또는 동기화 블록 내에서만 사용할 수 있다.

##### 스레드의 안전한 종료 (stop 플래그, interrupt())

Thread는 스레드를 즉시 종료시키기 위해 stop() 메소드를 제공하고 있는데, 이 메소드는 deprecated되었다. 그 이유는 stop() 메소드로 스레드를 갑자기 종료하게 되면 스레드가 사용 중이던 자원들이 불안전한 상태로 남겨지기 때문이다. 여기서 자원은 파일이나 네트워크 연결 등을 말한다.

###### stop 플래그를 이용

스레드는 run() 메소드가 끝나면 자동적으로 종료되므로, run() 메소드가 정상적으로 종료되도록 유도하는 방법이 있다.

```java
public class XXXThread extends Thread {
	private boolean stop;	// stop 플래그 필드
	
	public void run() {
		while(!stop) {
			스레드가 반복 실행하는 코드;
		}
		// 스레드가 사용한 자원 정리
	}
}
```

###### interrupt() 메소드를 이용하는 방법

interrupt() 메소드는 스레드가 일시 정지 상태에 있을 때 InterruptedException 예외를 발생시키는 역할을 한다. 이것을 이용하면 run() 메소드를 정상 종료시킬 수 있다.