\# Collection Framework 

 

\##### - 책 '이것이 자바다'를 참고해서 작성한 문서입니다. 

 

 

 

배열은 쉽게 생성하고 사용할 수 있지만, 저장할 수 있는 객체 수가 배열을 생성할 때 결정되기 때문에 불특정 다수의 객체를 저장하기에는 문제가 있다. 또 다른 문제점은 객체를 삭제했을 때 해당 인덱스가 비게 된다. 그렇기에 새로운 객체를 저장하려면 어디가 비어 있는지 확인하는 코드도 필요하다. 

 

\###### 배열 

 

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 

| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | 

| O    | O    | X    | O    | X    | O    | X    | O    | O    | X    | 

 

자바는 배열의 이러한 문제점을 해결하고, 널리 알려져 있는 자료구조(Data Structure)를 바탕으로 객체들을 효율적으로 추가, 삭제, 검색할 수 있도록 java.utill 패키지에 컬렉션과 관련된 인터페이스와 클래스들을 포함시켜 놓았다. 이들을 총칭해서 ***\*컬렉션 프레임워크(Collection Framework)\****라고 부른다. 자바 컬렉션은 ***\*객체를 수집해서 저장하는 역할\****을 한다. 프레임워크란 ***\*사용 방법을 미리 정해 놓은 라이브러리\****를 말한다. 주요 인터페이스로는 List, Set, Map이 있다. 이 인터페이스들은 컬렉션을 사용하는 방법을 정의한 것이다. 

 

인터페이스로 사용 가능한 컬렉션 클래스 

 

ArrayList, Vector, LinkedList는 List 인터페이스를 구현한 클래스로, List 인터페이스로 사용 가능한 컬렉션이다. 

 

HashSet, TreeSet은 Set 인터페이스를 구현한 클래스로, Set 인터페이스로 사용 가능한 컬렉션이다. 

 

HashMap, Hashtable, TreeMap, Properties는 Map 인터페이스를 구현한 클래스로 Map 인터페이스로 사용 가능한 컬렉션이다. 

 

List와 Set은 객체를 추가, 삭제, 검색하는 방법에 많은 공통점이 있기 때문에 이 인터페이스들의 공통된 메소드들만 모아 Collection 인터페이스로 정의해 두고 있다. Map은 키와 값을 하나로 묶어서 관리하는 구조로 되어 있어서 List와 Set과는 사용 방법이 다르다. 

 

인터페이스별로 사용할 수 있는 컬렉션의 특징 

 

| 인터페이스 분류 | "    | 특징                                        | 구현 클래스                             | 

| --------------- | ---- | ------------------------------------------- | --------------------------------------- | 

| Collection      | List | 순서를 유지하고 저장. 중복 저장 가능        | ArrayList, Vector, LinkedList           | 

| Collection      | Set  | 순서를 유지하지 않고 저장. 중복 저장 안 됨  | HashSet, TreeSet                        | 

| Map             | -    | 키와 값의 쌍으로 저장. 키는 중복 저장 안 됨 | HashMap, Hashtable, TreeMap, Properties | 

 

 

 

\#### List 컬렉션 

 

List 컬렉션은 객체를 일렬로 늘어놓은 구조를 갖고 있다. 객체를 인덱스로 관리하기에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색,  삭제할 수 있는 기능을 제공한다. List 컬렉션은 객체를 저장하는 것이 아니라 객체의 번지를 참조한다. 따라서 동일한 객체를 중복 저장할 수 있고, 이 경우에는 동일한 번지가 참조된다. null도 저장이 가능하며 이때 해당 인덱스는 객체를 참조하지 않는다. 

 

List 컬렉션에서 공통적으로 사용 가능한 List 인터페이스의 메소드들. 인덱스로 객체를 관리하기 때문에 인덱스를 매개값으로 갖는 메소드가 많다. 

 

| 기능      | 메소드                         | 설명                                             | 

| --------- | ------------------------------ | ------------------------------------------------ | 

| 객체 추가 | boolean add(E e)               | 주어진 객체를 맨 끝에 추가                       | 

| "         | void add(int index, E element) | 주어진 인덱스에 객체를 추가                      | 

| "         | E set(int index, E element)    | 주어진 인덱스에 저장된 객체를 주어진 객체로 바꿈 | 

| 객체 검색 | boolean contains(Object o)     | 주어진 객체가 저장되어 있는지 여부               | 

| "         | E get(int index)               | 주어진 인덱스에 저장된 객체를 리턴               | 

| "         | boolean isEmpty()              | 컬렉션이 비어 있는지 조사                        | 

| "         | int size()                     | 저장되어 있는 전체 객체 수를 리턴                | 

| 객체 삭제 | void clear()                   | 저장된 모든 객체를 삭제                          | 

| "         | E remove(int index)            | 주어진 인덱스에 저장된 객체를 삭제               | 

| "         | boolean remove(Object o)       | 주어진 객체를 삭제                               | 

 

표에서 메소드의 매개 변수 타입과 리턴 타입에 E라는 타입 파라미터가 있는데, 이것은 List 인터페이스가 제네릭 타입이기 때문이다. 구체적인 타입은 구현 객체를 생성할 때 결정된다. 

 

객체 추가는 add() 메소드를 사용하고, 객체를 찾아올 때는 get() 메소드를 사용한다. 그리고 객체 삭제는 remove() 메소드를 사용한다.